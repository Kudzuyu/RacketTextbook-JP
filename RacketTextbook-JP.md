# 序文と下準備
## この文書について
この文書は、現在日本語の情報が少ないプログラミング言語Racketについて、プログラミング初心者の方でもわかりやすいように解説し、Racketのプログラミングがある程度できるようになることを目指しています。これからプログラミングを始める人のために経験者の方には少し表現がくどくなっているかもしれませんが、ご了承ください。最新版は、[Githubのリポジトリ](https://github.com/Kudzuyu/RacketTextbook-JP)からダウンロードすることができます。

## はじめに-RacketとLisp
1950年代に、ジョン・マッカーシーという人により、Lispというプログラミング言語が作られました。Lispは当時の主流であったプログラミング言語(FortranやCobolなど)とは構造がかけはなれていたため、あまり流行ることもなく、また当時のコンピュータの処理性能にたいしては重たい言語であったためさほど普及しませんでしたが、他の言語にはない様々な機能があったため、人工知能などの研究用として残りつづけました。
Lispはその後、2つの大きな方言(元のプログラミング言語にたいし基本構造はかわらないが、細かな違いや改良がみられるプログラミング言語)を産みました。Common LispとSchemeです。それぞれに目指しているものが違い、Common Lispは多機能で様々なプログラムができるように、Schemeは言語としてのシンプルさを追求していました。
Racketは、Schemeから派生したLisp方言の1つです。かつてはPLT Schemeと呼ばれていました。RacketはSchemeとの互換性もありながらかなり多機能な言語となっており、Common LispとSchemeの中間的存在と言えるかもしれません。

### Racketの特徴
* RacketはSchemeから派生したため、Schemeとよく似ています。そのため、Schemeを強化するために作られたライブラリ集srfiを組み込んで使うことができます。（現在Racketで使えるsrfiは、[Racketのsrfiのページ](http://docs.racket-lang.org/srfi/index.html)を参照してください。）
* RacketにはデフォルトでGUIの開発に必要な関数郡が揃っています。これにより、これまでのCommon LispやSchemeでは環境をそろえることすら難しかったGUIについて、手軽に触れることができるようになっています。
* schemeは、必要最小限の言語であることを目指しているため、実用にはあまり向かない言語になっていますが、Racketは前述のGUIを始め、多数のライブラリを揃えており、本格的なソフトウェア開発にも適しています。

## Racketプログラミングのための準備
Racketは公式がプログラミング用のソフト(IDE)を配布しているので、とりあえずはこれを使うことをお勧めします。自分のお気に入りのエディタがあるひとはそれを使ってもいいとおもいますが、マイナーな言語ですのでエディタによってはシンタックスハイライト(ソースコードの色分けや、文法ミスの検出などの機能のこと。ソースコードを見やすくするためのもので、なくても問題はありませんがあったほうが捗ります)がないこともあります。

### インストール
* **Windows** <br>
[Racket公式サイト](http://racket-lang.org)にアクセスし、画面上部の「Download」をクリック。Distributionが「Racket」、PlatformがWindowsであることを確認して、ダウンロード。exe形式なので、そのままインストールしてください。一応ミラーサイトもあります。

* **Mac** <br>
Windowsと同じようにRacketの公式サイトからダウンロードしてください。他の方法もあるかもしれませんが、筆者はMacを使ったことがないのでわかりません。公式サイトからで問題はないと思います。

* **Linux(Debian,Ubuntu系)** <br>
Windows、Macと同じようにRacketの公式サイトからダウンロードする方法と、aptリポジトリを使う方法があります。リポジトリは ppa:plt/racketです(公式リポジトリで、アップデートを自動でやってくれるためこちらのほうがおすすめです。)


* **Minimal RacketとRacketの違いについて**  
  Racketをダウンロードするときに、Minimal Racketというものが選択肢にあるとおもいます。これは、Racketとしての必要最低限の機能だけを搭載し、あとからパッケージという形でRacketに機能を追加できるようにしたパッケージです。この文書は、普通のRacketを導入することを前提で書いていますので、特に理由がなければRacketをダウンロードすることをおすすめします。

### 起動および日本語化  
インストールすると、ソフト一覧に、DrRacketが追加されると思います。これがRacketのIDEです。この記事では、これを使ってプログラミングすることを想定して書かれています。他のエディタを使っている人は、適宜読みかえてください。 <br>
DrRacketを起動すると英語版として立ちあがるかもしれません。このままでも問題はありませんが、日本語がいいという方は、メニュータブの右端「Help」をクリックしてください。さまざまな言語でかかれたメニューの中に、「DrRacketを日本語で使う」という項目があると思います。クリックすると、DrRacketを再起動するか聞かれるので、承認して再起動させましょう。これを行なうことで、それ以降はDrRacketを日本語で使えるようになります。

### ライセンスと商用利用について
Racketは、LGPL(Lesser General Public License)により配布されています。これは、商用利用に関して問題が起きることがあります。(Googleなどで、「LGPL 商用」などで調べると、様々な意見が混在していることがわかると思います。)Racketのサイトでは、商用開発に関して制限するつもりはないと書かれていますが、まだ見送ったほうがいいでしょう。(どうしてRacketがLGPLで配布されているかというと、使っているライブラリの中に、LGPLで配布されているものがあるからです。)もしどうしても商用プログラムを開発したいという方は、同じScheme系の処理系のGaucheや、有名なLisp系方言の一つであるCommon Lispなどで開発することをすすめます。Gaucheでは、Racket特有の関数以外は共通に使うことができますし、Common Lispは機能の点において、Racketにおとりません。(文法がすこし違っていますが、なれれば気にならないでしょう。)

### ドキュメントについて
Racketは、公式サイトにてドキュメント(辞書のようなもの)や初心者向けの文書が公開されていますが、全て英語なので非効率です。ただ、新機能のアナウンスや新機能の解説などはそちらの方が早いので、英語が読める人はのぞいてみるのがいいでしょう。

### まとめ
* Lispの一方言、Racket
* ダウンロードは公式サイトから
* 開発環境もついてくるので手軽に始められます。
* 商用利用はおすすめしません。

# プログラミングRacket Racket基礎編
ここではRacketの基本的な文法について解説します。Racketの派生元であるSchemeの解説としても使えると思います。

## Racket基礎その1 Hello World!とリストに関する各種名称

### まずはお決まり、Hello World!
DrRacketを起動させると、#lang racket と書かれたエディタ部分、その下の、シェルの部分が目につくと思います。これは、Lisp系の言語の開発環境にはかならずといっていいほど付属する対話環境とよばれるものです。他のプログラミング言語とはすこし違いますが、使っていくうちになれます。

それでは、Racketのプログラミングを始めていきましょう。まずは、色々な言語で最初にやる画面に「Hello World!」と表示するプログラムを作ってみましょう。以下のコードを書きこんでください。全ての文字は、半角を使用してください。(#lang racketの部分は、もとから書かれていますので、これ以降は基本省略します)

```racket
#lang racket

(display "Hello World!")

```
書き込んだら実行してみましょう。ソフト上部の「実行」と書かれた緑色の三角形のボタンを押してください。(保存しなくても実行できます。)
実行すると、画面下部の対話環境に、以下の様に表示されると思います。
エラーメッセージがでた人は、カッコが半角であるかや、全角空白が入っていないかどうかを確認してください。
```racket
Hello World!
>
```

では、このプログラムについてみていきましょう。
Racketの世界では、全てのプログラムおよびデータは()-丸カッコでくくられます。これをリストといいます。Racketの世界では、プログラムとプログラムで扱うデータを同じようにリストで表現します。このうち、プログラムとしてのリストは、先頭の要素および残りの要素に大別されます。このプログラムでいうと、「display」が先頭の部分にあたり、「"Hello World!"」が残りの部分にあたります。プログラムとしてのリストの先頭と残りには、それぞれ役割があります。先頭の要素がプログラムの名前であり、残りの要素が「引数(ひきすう)」と呼ばれる、そのプログラムの動作を決定するものです。
このプログラムの場合、「display」というのが画面に文字を入力せよという命令(関数といいます)であり、「"Hello World!"」がdisplayに対する引数となっています。
"Hello World"の""の中を自分の好きな文字列に変えて、実行してみてください。自分の入れた文字列が表示されたはずです。displayという命令が変わっていないので画面に文字列を出力するということは同じですが、引数が違うため微妙に動作が違うのです。


### Racketの構造
先ほど、関数とデータが、同じリストという構造でできているという話がありました。今度は、Racketのデータについても見ていきましょう。
Racketでは、リストを次のように書きます。次のリストは、a、b、cの3つの要素をもつリストです。
```racket
(a b c)
```
リストは多層構造にもできます。次のリストは、1年の各月とその月のを表わしたリストです。
```racket
((1 31)(2 28)(3 31)(4 30)(5 31)(6 30)(7 31)(8 31)(9 30)(10 31)(11 30)(12 31))
```

リストの先頭要素が関数であった場合に、その関数を実行することを評価といいます。さきほどの
```racket
(display "Hello World!")
```
のプログラムは、関数「display」に引数「"Hello World!"」を評価させていたということです。
では、このdisplayに、リストを与えてみましょう。
```racket
(display (1 2))
```
これを実行すると、エラーがでます。
```racket
. . application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
  arguments.:
>
```
このエラーは、リストを引数に与えたからでたわけではありません。引数として与えられたリストの先頭のアトムが、関数でなかったからおきたものです。  
プログラムを実行すると、Racketはリストの先頭の要素を見にいきます。displayはRacketで関数として登録されているので、その定義にしたがってリストの残りの要素を画面に出力しようとします。すると、残りの要素はリストということになりました。このときRacketは、そのリストを評価しにいきます。このプログラムでは、(1 2)の部分です。しかし先頭の要素が「1」で、関数ではないためRacketは評価ができず、エラーを返したのです。
このような場合にはどうすればいいでしょうか。次のプログラムを見てください。
```racket
(display '(1 2))
```
このプログラムを実行すると、エラーが出ずに、(1 2)と出力されます。実は、リストの前に'(クオート)を付けるとRacketはそのリストを単なるデータとみなし、評価をしないのです。
皆さんも様々なリストを入れてみてください。なお、Hello worldの時のように"(1 2)"としても出力することができますが、リストに対しては、'を使ったほうが便利なことが多いので、リストに対してはこちらを使っていきましょう。

### まとめ
* Racketはリストとよばれる()を使った構造で、プログラムやデータを書く。
* リストは、多層構造にすることができる。
* Racketのプログラムを実行すると、リストの先頭の要素は
* リストを評価するとcar部を関数としcdr部を引数として実行する。
* リストを評価されたくない時は、前カッコの前に'(クオート)をつける。


## Racket基礎その2 リストの操作とアトムについて
### 対話環境の使い方
さて、前回まではエディタ部分にプログラムを書いて実行してきました。しかし、一々前回のプログラムを消して書きなおすのも面倒です。これまでプログラムを実行すると下の対話環境に出力されていましたが、そこに直接プログラムを書いてみましょう。次のプログラムを書いて、エンターキーを押してください。
```racket
>(display '(one two three))
'(one two three)
```
エディタ部分に書いて実行したときと同じように、displayが実行されました。このように対話環境は、テキストに書かれたプログラムの実行だけでなく、直接プログラムを実行することもできるのです。そして、この方式だと、直ぐに次のプログラムを書きこむことができて便利です。
今の所、対話環境だけで押し通してもRacketの習得上問題はないので、当分は手軽に対話環境にプログラムを直接打ち込む方式でいきましょう。(プログラムをテキストに書きこむ方式がいいという人は、別にかまいません。結果がかわるわけではありませんから)やがてテキストに書くプログラムが必要になったら、あらためてテキストに戻ることにしましょう。
なお、対話環境に書きこんで実行している時は、プログラムの先頭に「>」を付けてありますので、それが無いときはテキストに書きこむ方のプログラムだと考えてください。

### リストの各要素は、アトム
もう少しプログラミング以前の話がつづきます。
前回までで、リスト(1 2 3)の1や2などを、要素と呼んできましたが、これからはRacketおよびLispの伝統にしたがって、アトムとよぶことにします。アトムとは英語で「元素」の意味であり、リストを構成しているものという感じがしますね。アトムが組みあわされたリストは、「分子」といったところでしょうか。
```racket
((a b) (c (d e)))
```
上のように多層構造のリストの場合、アトムは、a、b、c、d、eの5つのことです。全てのカッコをとったのこりと考えるとわかりやすいでしょう。

### リスト操作のおきまり、carとcdr
では今回の本題です。今回は、リストの中から特定のアトムを抜きだす操作を覚えましょう。次のプログラムを実行してください。
```racket
(car '(a b c))
```

```lisp
(cdr '(a b c))
```

いかがでしたでしょうか。それぞれリストの先頭のアトム「a」および残りの部分「'(b c)」が出力されたと思います。クダー部のリストに'がついているのは、評価前のリストがすでに'で評価されないようにしていたからです。また、カー部であるaの方に'がついていないのは、数字に関しては評価しないという取り決めがあるからです。(先程のdisplayとは、出力時の文字の色が違うかもしれませんが、いまは気にしないでください)
これらの関数はRacketの先祖であるLispができたころから存在していたいにしえの関数です。Racketに限らずLisp系の言語はリストの操作にこの名前を使っている名前が多いです。
これまでリストを先頭の要素と残りの要素というふうに分けてきましたが、これらの関数名に従い、これからはそれぞれ先頭の要素をcar(カー)、残りの要素をcdr(クダー)と呼ぶことにします。
リストは、多層構造にすることもできるという話をしました。では、次のプログラムを見てください。

```racket
(car '((1 2)(3 4)))
```

```racket
(cdr '((dog)(cat (mouse rabbit))))
```
これを実行すると
```racket
>(car '((1 2)(3 4)))
'(1 2)
>(cdr '((dog)(cat (mouse rabbit))))
'(cat (mouse rabbit))
```
このようになりました。リストが多層構造になっている時に、carやcdrをとると、リストの中のリストは、アトムと同じように
それでは練習問題です。以下のリストについてcarとcdrを推測してください。
ヒント:carとcdrを考える時のコツは、リストの一番外側の「(」前カッコを、右に一つずらすということです。
**練習1**
```racket
(1 2 3 4 5)
((1 2)(3 4))
(((1))(1 2))
```
いかがでしたか。章末に答えをのせていますが、実際に打ちこんでしらべた方がはやいかもしれません。もし巻末の答えが実際の挙動と違っていた場合は、githubのissuesにお願いします。
ではもうひとつ、
```racket
(a)
```
これのcarとcdrをとってみましょう。carは予測がつくと思いますが、cdrはどうなるでしょう。
```racket
>(car '(a))
a
>(cdr '(a))
'()
```
中にアトムがない、ただのカッコがでてきました。これは空リストとよばれるもので、要素を1つも持たないリスト(要素0個のリスト)です。では、このリストのcarとcdrを取るとどうなるでしょう。

```racket
>(car '())

>(cdr '())
```
どちらもエラーがでました。Racketでは空リストのcarやcdrをとってはいけないことになっています。これは後々条件分岐の所で重要になってきますので、気にとめておいてください。(他のLisp系言語をやったことのあるひとは、空リストのcdrがエラーになることや、nilが出ないことなどに違和感をいだくかもしれませんが、わりきってください)
Racketの定義では、carとcdrは、1つ以上のアトムを含むリストを引数にとることとなっています。

### carとcdrの複合技
ここまで、carとcdrでリストを評価するとどこのアトムやリストがでてくるのかをみてきました。では、リストの2番目や3番目の要素が必要になったときは、どうすればいいでしょう。
ここで、cdrに注目してみましょう。
```racket
>(cdr '(1 2 3))
(2 3)
```
上のプログラムで、carをとったあとのリストを見てみると、これもリストであり、carやcdrをつかうことができる構造になっています。これで、リストの2番目のアトムを取りだすめどがたちました。
```racket
>(cdr '(1 2 3))
'(1 2)
>(car '(1 2))
1
```
このようになりました。今は一回づつやりましたが、これは組みあわせて使うことができます。
```racket
>(car (cdr '(1 2 3)))
1
```
このプログラムを実行すると、Racketは始めにリストの先頭要素をみて、carなので残りのリストを評価しようとします。しかし、評価すべきリストもcdrのプログラムなので、中のcdrを先に評価して評価した値をcarに渡すのです。
このようにして、リストの2番目や3番目をとりだすことができました。ところで、Racketにはリストの2番目や3番目を一発で返す関数も用意されています。cadrや、caddrなどです。
```racket
>(cadr '(chicken pork beef))
'pork
>(caddr '(tuna salmon swordfish))
'swordfish
```
carやcdrの組みあわせ技なので、命名規則もそれにのっとっています。c{}rの{}のあいだには、carを表すaか、cdrを表わすdかが、その関数を使う順番に**後ろから**はいっています。つまり、caddrならcdr→cdr→carと実行したのとおなじということです。一見後ろからいれるのは不思議に思えるかもしれませんが、先程の入れ子プログラムをみるとわかりやすいかと思います。
```racket
(car (cdr '(1 2 3)))
(cadr '(1 2 3))
```
この2つのプログラムは同じはたらきをします。cadrのaとdの並び方が入れ子にしたプログラムのcarとcdrの位置関係と同じことに気づかれたでしょうか。わからなくなったときは入れ子のプログラムを思いだすと理解しやすいとおもいます。
なおcarとcdrの複合関数は、いくらでも使えるというわけではなく、caddddrくらいまでとなっています。これ以降のアトムを取りだしたいときは、(cadddr (cddddr ...))という風にするのが得策でしょう。あえてリストの20番目を一発でとる関数などがほしい人も、ここから何章か進んだ関数定義の章や再帰定義の章などを学習することで自分で作ることができるようになります。

### まとめ
* リストを構成する各要素のことをアトムという。
* リストの先頭のアトムはcar、先頭を除く残りのリストはcdrで取り出すことができる。
* carとcdrはリストを入れ子にすることで2番目以降のアトムを取りだすことができる。
* 入れ子にする以外にも、リストの5番目程度まではcadrやcaddrなどの関数が用意されている。
* それ以上の場合は、入れ子にするか後々関数定義や再帰定義などを学ぶことで自分で作ることができる。

### 練習問題の解答
```racket
>(car '(1 2 3 4 5))
1
>(cdr '(1 2 3 4 5))
(2 3 4 5)
>(car '((1 2)(3 4)))
((1 2))
>(cdr '((1 2)(3 4)))
((3 4))
>(car '(((1))(1 2)))
((1))
>(cdr '(((1))(1 2)))
(1 2)
```

## Racket基礎その3 リストを作る
### carとcdrの逆関数、cons
前回は、リストの中からアトムやリストを抜き出す操作をやってきました。今回は、リストを作りだす関数についてです。
```racket
>(cons 'a '(b c))
(a b c)
```
## Racket基礎その4 算術計算と条件演算子
### リストで計算
前回までは、リスト操作の基本関数であるcarとcdr及びその派生関数について解説してきました。今回は少し趣向がかわりまして、計算を行なう関数と、条件演算子とよばれるものについてです。次回以降の自分で関数定義をしていく章において重要となってくるので、がんばってください。

まずは、リストを使って計算をしましょう。Racketには、displayやcarなどのように、数学的な計算を行う関数も用意されています。四則演算を行う関数のことを特別に、算術演算子といいます。
```racket
(+ 2 4)
(- 12 4)
(* 5 9)
(/ 35 7)
```
これらは上から順に、足し算、引き算、かけ算、割り算をあらわしています。かけ算で×を使わないのは、キーボードに×の記号を表す文字がなかったからです。これに関しては覚えてください。割り算が/なことに関しては、コンピューター上で分数をあらわす時の約束としてこれまでにも見たことがあるとおもいます。
なお、足し算とかけ算に関しては、引数をとらない関数も実行することができます。
```racket
>(+)
0
>(*)
1
```
これは数学的な考えにもとづいていて、
算術演算子がこれまでのcarなどと違う点は、引数をいくらでもとれるところです。
```racket
>(+ 1 2 3 4 5 6 7 8 9 10)
55
>(* (+ 2 2) (- 5 4) 2 4)
32
```
これは計算が楽になりそうですね。元々Racketの始祖であるLispは、数学的な考え方から生まれました。このように算術演算子を一番前において、後ろに計算する数字を並べる書き方のことを前置記法といいます。一方、私達が普段使っている、「3 + 4」などの書き方は、中置記法といいます。前置記法のいいところは、複数の数字にたいして同じ演算をする(まとめて足し算やかけ算をする)時に、算術演算子を1つ書けばすむことです。この考えかたが後々、Racketにでてくる算術演算子以外の、沢山の引数をとる関数などのところで役立つことになります。

### 条件判定
算術演算子に続いて、条件演算子について見ていきましょう。この関数群はそれ単体では大した機能をもちませんが、状況によって動作を変えるプログラムを作る時にとても役に立つものです。
条件演算子は、あたえられた引数にたいし、「真」をあらわす#tか「偽」をあらわす#fを返します。
```racket
>(list? '(a b))
#t
>(atom? '(a b))
#f
>(atom? 'a)
#t
```
上にあげたのは、条件演算子をつかった例です。関数名からなんとなく機能がわかると思います。list?は、与えられた引数がリストかどうかを、atom?は引数がアトムかどうかを調べます。「'」をつけるのを忘れないでください。
さて、今あげた関数は、いずれも引数が~であるか?を調べる、1引数の関数でした。しかし、これだけでは、2つの物を比較することができません。勿論、Racketにはそういう関数も用意されています。
```racket
>(= 10 10)
#t
>(= 10 9)
#f
>(> 10 9)
#t
>(< 10 9)
#f
>(>= 10 9)
#t
>(<= 10 9)
#f
```
条件演算子「=」は、与えられた2つの数字が等しいかどうかを判定します。「<」と「>」に関しては、大きいか小さいかを判定します。
最後の「>=」と、「<=」は、以上、以下を判定します。=の位置は、「<、>」よりも後に置かなければいけません。「=<」のようにするとエラーとなります。

条件演算子も、算術演算子と同じように、3個以上の値を取ることができます。
```racket
>(= 8 8 8 8)
#t
>(< 1 2 3 4 10)
#t
>(< 1 2 3 3 4 4)
#f
>(<= 1 2 2 3 3 4)
#t
```
普段の数学の表記になおすと、これは以下のようになります。個々の数字の間に、指定された算術演算子をあてはめてみて、正しい表記になっていたら、#tが、1つでも違っていたら#fが返ります。
```
(= 8 8 8 8 ) -> 8 = 8 = 8 = 8                     <-正しい
(< 1 2 3 4 10) -> 1 < 2 < 3 < 4 <10               <-正しい
(< 1 2 3 3 4 4) -> 1 < 2 < 3 < 3 < 4 < 4          <-3 < 3と、4 < 4が正しくない。
(<= 1 2 2 3 3 4) -> 1 <= 2 <= 2 <= 3 <= 3 <= 4    <-正しい
```
## 関数定義
### defineで関数を定義
いよいよ今回から、自分で関数を定義していきます。これによって、一応Racketのプログラムが書けるようになります。今回からは、又プログラムを上のファイルに書きこんでいきましょう。今回使う関数は、defineというものです。defineの構造はこれまでの関数と少しちがっていて、次のようになっています。
```racket
(define (関数名 引数...) (関数の内容))
```
これまでの関数と違うところは、まず、引数を評価しないことです。例として、与えられた数を二乗する関数をみてみましょう。関数名はsquareとします。
```racket
(define (square x) (* x x))
```
これをファイルの方に書いて、実行すると、テキストカーソルが下の対話環境の方に移ると思います。ここで、関数squareを実行してみましょう。

```racket
>(square 15)
225
```
ちゃんと答えが返ってきました。racketでは、ユーザーの作った関数は、もとからある関数と同じように使うことができます。したがって、関数の入れ子を、ユーザーの作った関数と、基本関数だけで作ることもできます。
```racket
>(square (car '(11 12 13)))
121
```
このように書いた場合、もしdefineが引数を評価してしまうと、squareという関数がないのでエラーがでてしまうのです。ではdefineはどのような動きをするのでしょうか。S式同士を接続するというのが、defineの動きの表現としていいかもしれません。例えば上のsquareの式では、(square x) と、(* x x)が接続されるのです。この後、(square 5)などという式を実行すると(* x x)という式に、ｘに5を代入して、(* 5 5)が評価されることとなります。
ところで、シェルでdefineしたときに、これまでと違うことがあることに気付かれたでしょうか。これまでの関数は、即時結果を返すものでしたが、defineはなにもかえってきていません。実はdefineは実行されても返り値を返さないのです。
### defineで定数を定義する。
defineは値を設定することにも使えます。次の例を見てください。
```racket
>(define x 20)

>(+ x 10)
20

```
xに値10が設定されました。この方法をつかうと、特定の数字や文字などを、簡略化して使いまわすことができます。
```scheme
(define pi 3.14)
(define (circle-area r)
  (* r r pi))
```
上のプログラムは最初に円周率piを設定し、次の関数で円の面積を求めています。こうしておくと、piの数値を3.1415などと変更したときに、面積のプログラムの方を変更する必要がないので、便利です。また、同じ定数を使う別のプログラム(上のプログラムでいえば、piを定義したことによって、球の体積や表面積などの関数)にも使いまわせます。実際のプログラムでは、値を定義する関数を先頭に書いておいて、その下にそれを使ったプログラムを書く形式になることが多いようです。

### defineの注意点
今後詳しく解説しますが、Racketにおいて元からある関数とユーザーが作った関数は、同じように一ヶ所で管理されます。このことは、元からある関数(例:carや、cdr、defineなど)を名前にした新しい関数をユーザーが作った場合、そのプログラムの中では、元の関数としての機能は失われてしまうということを意味しています。
```racket
>(* 2 3)
6
>(define * +)

>(* 2 3)
5
```
もともと「*」はかけ算の演算子ですが、「define」で「*」を「+」にしてしまったので、足し算になってしまいました。
このように、元からある関数を上書きしてしまわないように、注意しましょう。
これは、Common Lisp系のLispとScheme系のLispで違うことのひとつです。(Common Lispでは、ユーザーが作った関数と元からある関数は別に管理されているので、このようなことは起きません。くわしくは「Common Lisp 名前空間」などで調べてください。)
自分が作った関数が、既に定義されているかどうかを確認するには、Racketのドキュメントで検索してください。
## 条件分岐は多種多様
この回は、Racketの条件分岐について解説します。前々回に、Racketの条件演算子について学びました。今回はこれとdefineを使って、条件によって様々な変化をするプログラムを作っていきましょう。

### if文
最初は、単純な条件分岐である、if文を使ってみましょう。if文の構造は次のようになります。
```racket
(if (条件)
	(動作1)
	(動作2))
```
if文を実行すると、条件の文が評価されます。評価結果が真の場合は、動作1が、偽の場合は動作2が実行されます。
たとえば、受けとった数字が10より大きいか小さいかを判定する関数は、以下のようになります。

```racket
(define (ten x)
	(if (>= x 10)
		(display "10以上")
		(display "10より小さい")))
```
この関数は、引数xをとり、xが10以上が否かで、それぞれの動作をします。条件が真の時も偽の時も、片方の動作しか実行されないことに注意してください。もしも複数の動作をしたい時は、次のようにします。

(define (ten1 x)
	(if (>= x 10)
		((display "与えられた数")(display x)(display "は10以上です。"))
		((display "与えられた数")(display x)(display "は10より小さいです。"))))

### cond文
続いて、より一般的な条件分岐である、cond文を紹介します。condはifと違い、3方向以上の分岐も可能になっています。
```racket
(cond
	(条件1 動作1)
	(条件2 動作2)
	(条件3 動作3)
	...
)
```
condは、条件を上から順に評価し、評価結果が真になったときに、その条件式に対応した関数が実行されます。ifと同じように、関数を定義してみましょう。
```racket
(define (+-0 x)
	(cond
		((> x 0)(display "plus"))
		((= x 0)(display "0")
		((< x 0)(display "minus")))))
```
このプログラムを実行し、対話環境で試してみると以下のようになるでしょう。
```racket
>(+-0 4)
plus
>(+-0 -1)
minus
>(+-0 0)
0
```
ごらんのように、xの値によって3種類の動作をします。昔のLispは、condの方をメインにして、ifは脇役のような扱いが多かったようですが、最近の書籍等ではifの方を先に紹介する方がメジャーなようなので、このテキストもそれにならいます。
さて、ifでもcondでも気をつけなければいけないことがあります。次のプログラムはテストの点数xが50点未満、80点未満、80点以上について、それぞれの課題を表示するプログラムです。
```racket
(define (test-task x)
  (cond
    ((< x 80) 'print)
    ((< x 50) 're-test)
    (else  'pass)))
```
ところが、このプログラムは正常に動作しないのです。xにいくつか値をいれてみましょう。
```
>(test-task 80)
'pass
>(test-task 60)
'print
>(test-task 30)
'print
```
xに30をいれたとき、本当なら(< x 50)が評価されて、're-testが返されてほしいところですが、先にある(< x 80)が評価されてしまいました。
このような間違いは、条件式のならびを変えることで、訂正できます。以下が正しいプログラムです。

```racket
(define (test-task x)
  (cond
    ((< x 50) 're-test)
    ((< x 80) 'print)
    (else 'pass)))
```
## 繰り返しと再起定義
さて、condとifを覚えたので、条件分岐するプログラムを書くことができるようになりました。このあとは、繰り返しのプログラムを覚えていきましょう。
繰り返しのプログラムを書くには、「for」という関数を使います。forの形は次のようになります。
```rakcet

```
それでは、リストの一番最後の要素をとりだす関数を考えてみましょう。リストに含まれるアトムの数を、リストの長さとよぶことにします。
初めに、手作業で要素を求めるということをやってみましょう。
このばあい、最初はcdrを打ちつづけていけばいいでしょう。ただ、それをすると最終的に空リストがのこってしまいますので、最後だけcarを使いましょう。
これは以下のようになります。

* リストの長さが1のとき
```racket
>(car '(1))
1
```

* リストの長さが2のとき
```racket
>(car (cdr '(1 2)))
2
```

* リストの長さが3のとき
```racket
>(car (cdr (cdr '(1 2 3))))
3
```
法則が見えてきました。これを進めていくと下のようになります。
* リストの長さがnのとき
```racket
>(car (cdr (cdr ... (cdr '(1 2 3 ... n)))))
n
```
このプログラムを文章でまとめてみると、
* リストの長さが1の時は、carを実行
* リストの長さが2以上の時は、cdrを実行
これを再帰定義というテクニックで実装してみましょう。プログラムは次のようになります。
```racket
(define (last ls)
  (if (null? (cdr ls))
		(car ls)
		(last (cdr ls))))
```
再帰定義は、多くの事をやっているわけではありませんが、初心者には理解が難しいかもしれません。わからなければここは読みとばしてもけっこうです。


# プログラミングRacket ソフトウェア開発編
